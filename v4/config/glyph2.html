<!doctype html><body>
<script src="../glyphs.js"></script>
<style>canvas {box-shadow:0 0 10px rgba(0,0,0,0.5);}</style>
<script>

var ui = document.body.appendChild(document.createElement("CANVAS")), ctx = ui.getContext("2d");

ui.x = ui.offsetLeft; ui.y = ui.offsetTop;

var size = ui.width = ui.height = 500;

var g = glyphs.glyph("?",true,"48px Arial",{"x":13.1,"y":-2.3},18.5,"#26b423",30,1.41,1);

var pan = { x: size / 2, y: size / 2 }, _pan;
var dragging = null, drag_start = { x: 0, y: 0 }, mouse_start = { x: 0, y: 0 };

var to_render;

var radius_thickness = 10;
function from_centre(x, y) {
	var xd = x - (g.centre.x); if (xd < 0) { xd = -xd; }
	var yd = y - (g.centre.y); if (yd < 0) { yd = -yd; }
	var from_centre = Math.sqrt((xd * xd) + (yd * yd));
	return from_centre;
}
function over_radius(mouse_start) {
	var from_radius = from_centre(mouse_start.x,mouse_start.y) - g.radius;
	
	return (over_radius.is = (from_radius > -radius_thickness / 2 && from_radius < radius_thickness / 2));
}

var scale = 1, scale_rate = 1.1;
var mouse_x = "pageX", mouse_y = "pageY";
var LMB = 0, MMB = 1, RMB = 2;

{ // input
	ui.onwheel = function(e) {
		e.preventDefault();
		
		if (e.deltaY > 0) { scale *= scale_rate; }
		else if (e.deltaY < 0) { scale *= 1 / scale_rate; }
		
		if (!to_render) { to_render = requestAnimationFrame(render_ui); }
	};
	ui.oncontextmenu = function(e) {
		e.preventDefault();
	};
	ui.onmousedown = function(e) {
		e.preventDefault(); e.stopPropagation();
		if (!dragging) {
			mouse_start = get_mouse_pos(e);
			if (e.button === MMB || e.button === RMB) {
				dragging = _pan = { x: pan.x, y: pan.y };
			}
			else if (e.button === LMB) {
				if (over_radius(mouse_start)) { dragging = "radius size"; }
				else { dragging = g.centre; }
			}
			
			if (dragging && dragging !== "radius size") {
				drag_start.x = dragging.x; drag_start.y = dragging.y;
			}
		}
	};
	
	window.onmousemove = function(e) {
		var current_mouse = mouse_pos = get_mouse_pos(e);
		if (dragging) {
			if (dragging === "radius size") {
				g.radius = from_centre(current_mouse.x, current_mouse.y);
			}
			else {
				dragging.x = drag_start.x + (current_mouse.x - mouse_start.x);
				dragging.y = drag_start.y + (current_mouse.y - mouse_start.y);
			}
		}
		else {
			over_radius(current_mouse);
		}
		
		if (!to_render) { to_render = requestAnimationFrame(render_ui); }
	};
	window.onmouseup = function() {
		if (dragging === _pan) { pan.x = _pan.x; pan.y = _pan.y; }
		_pan = null;
		
		dragging = null;
	};
}

function get_mouse_pos(e) {
	return {
		x: ((e[mouse_x] - ui.x - pan.x) / scale),
		y: ((e[mouse_y] - ui.y - pan.y) / scale)
	};
}

var mouse_pos, mouse_debug = false;
function render_ui() {
	ui.width = ui.width;
	
	var p = _pan || pan;
	console.log(_pan);
	
	ctx.fillRect(0, 0, size, size);
	
	ctx.translate(p.x, p.y);
	ctx.scale(scale, scale);
	
	ctx.globalCompositeOperation = "destination-out";
	ctx.beginPath();
	ctx.arc(g.centre.x, g.centre.y, g.radius, 0, Math.PI * 2, true);
	ctx.fill();
	
	ctx.globalCompositeOperation = "source-over";
	var o;
	ctx.beginPath();
	ctx.lineWidth = 1 / scale;
	ctx.moveTo(g.centre.x, g.centre.y - g.radius); ctx.lineTo(g.centre.x, g.centre.y + g.radius);
	ctx.moveTo(g.centre.x - g.radius, g.centre.y); ctx.lineTo(g.centre.x + g.radius, g.centre.y);
	ctx.stroke();
	
	ctx.globalCompositeOperation = "xor";
	ctx.font = g.font;
	ctx.textBaseline = "middle";
	ctx.fillText(g.char, 0, 0);
	
	if (over_radius.is) {
		ctx.globalCompositeOperation = "screen";
		ctx.beginPath();
		ctx.strokeStyle="rgba(255,0,0,0.5)";
		ctx.lineWidth = radius_thickness;
		ctx.arc(g.centre.x, g.centre.y, g.radius, 0, Math.PI * 2);
		ctx.stroke();
	}
	
	if (mouse_debug && mouse_pos) {
		ctx.globalCompositeOperation = "source-over";
		ctx.fillStyle="green";
		ctx.beginPath();
		ctx.arc(mouse_pos.x,mouse_pos.y,10/scale, 0,Math.PI * 2);
		ctx.fill();
	}
	
	to_render = 0;
}
render_ui();

</script>

<script src="http://localhost:35729/livereload.js"></script>